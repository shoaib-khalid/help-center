{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, ComponentFactoryResolver, Directive, Pipe, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { of, from, Subject, BehaviorSubject, forkJoin, combineLatest, EMPTY } from 'rxjs';\nimport { take, map, retry, tap, catchError, shareReplay, switchMap } from 'rxjs/operators';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\n\nclass DefaultLoader {\n  constructor(translations) {\n    this.translations = translations;\n  }\n\n  getTranslation(lang) {\n    return of(this.translations.get(lang) || {});\n  }\n\n}\n\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\nfunction getValue(obj, path) {\n  if (!obj) {\n    return obj;\n  }\n  /* For cases where the key is like: 'general.something.thing' */\n\n\n  if (Object.prototype.hasOwnProperty.call(obj, path)) {\n    return obj[path];\n  }\n\n  return path.split('.').reduce((p, c) => p === null || p === void 0 ? void 0 : p[c], obj);\n}\n\nfunction setValue(obj, prop, val) {\n  obj = Object.assign({}, obj);\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n    }\n\n    return acc && acc[part];\n  }, obj);\n  return obj;\n}\n\nfunction size(collection) {\n  if (!collection) {\n    return 0;\n  }\n\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n\n  return collection ? collection.length : 0;\n}\n\nfunction isEmpty(collection) {\n  return size(collection) === 0;\n}\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\nfunction isObject(item) {\n  return !!item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase()).replace(/\\s+|_|-|\\//g, '');\n}\n\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\nfunction isDefined(value) {\n  return isNil(value) === false;\n}\n\nfunction toNumber(value) {\n  if (isNumber(value)) return value;\n\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n\n  return null;\n}\n\nfunction isScopeObject(item) {\n  return item && typeof item.scope === 'string';\n}\n\nfunction hasInlineLoader(item) {\n  return item && isObject(item.loader);\n}\n\nfunction unflatten(obj) {\n  return unflatten$1(obj);\n}\n\nfunction flatten(obj) {\n  return flatten$1(obj, {\n    safe: true\n  });\n}\n\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory: () => {\n    return {\n      defaultLang: 'en'\n    };\n  }\n});\nconst defaultConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  },\n  interpolation: ['{{', '}}']\n};\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\n\nfunction translocoConfig(config = defaultConfig) {\n  return Object.assign(Object.assign({}, defaultConfig), config);\n}\n\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\n\nclass DefaultTranspiler {\n  constructor(userConfig) {\n    this.interpolationMatcher = resolveMatcher(userConfig);\n  }\n\n  transpile(value, params = {}, translation) {\n    if (isString(value)) {\n      return value.replace(this.interpolationMatcher, (_, match) => {\n        match = match.trim();\n\n        if (isDefined(params[match])) {\n          return params[match];\n        }\n\n        return isDefined(translation[match]) ? this.transpile(translation[match], params, translation) : '';\n      });\n    } else if (params) {\n      if (isObject(value)) {\n        value = this.handleObject(value, params, translation);\n      } else if (Array.isArray(value)) {\n        value = this.handleArray(value, params, translation);\n      }\n    }\n\n    return value;\n  }\n  /**\n   *\n   * @example\n   *\n   * const en = {\n   *  a: {\n   *    b: {\n   *      c: \"Hello {{ value }}\"\n   *    }\n   *  }\n   * }\n   *\n   * const params =  {\n   *  \"b.c\": { value: \"Transloco \"}\n   * }\n   *\n   * service.selectTranslate('a', params);\n   *\n   * // the first param will be the result of `en.a`.\n   * // the second param will be `params`.\n   * parser.transpile(value, params, {});\n   *\n   *\n   */\n\n\n  handleObject(value, params = {}, translation) {\n    let result = value;\n    Object.keys(params).forEach(p => {\n      // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n      const v = getValue(result, p); // get the params of \"b.c\" => { value: \"Transloco\" }\n\n      const getParams = getValue(params, p); // transpile the value => \"Hello Transloco\"\n\n      const transpiled = this.transpile(v, getParams, translation); // set \"b.c\" to `transpiled`\n\n      result = setValue(result, p, transpiled);\n    });\n    return result;\n  }\n\n  handleArray(value, params = {}, translation) {\n    return value.map(v => this.transpile(v, params, translation));\n  }\n\n}\n\nDefaultTranspiler.ɵfac = function DefaultTranspiler_Factory(t) {\n  return new (t || DefaultTranspiler)(i0.ɵɵinject(TRANSLOCO_CONFIG, 8));\n};\n\nDefaultTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultTranspiler,\n  factory: DefaultTranspiler.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultTranspiler, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\nfunction resolveMatcher(userConfig) {\n  const [start, end] = userConfig && userConfig.interpolation ? userConfig.interpolation : defaultConfig.interpolation;\n  return new RegExp(`${start}(.*?)${end}`, 'g');\n}\n\nfunction getFunctionArgs(argsString) {\n  const splitted = argsString ? argsString.split(',') : [];\n  const args = [];\n\n  for (let i = 0; i < splitted.length; i++) {\n    let value = splitted[i].trim();\n\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n\n    args.push(value);\n  }\n\n  return args;\n}\n\nclass FunctionalTranspiler extends DefaultTranspiler {\n  constructor(injector) {\n    super();\n    this.injector = injector;\n  }\n\n  transpile(value, params = {}, translation) {\n    let transpiled = value;\n\n    if (isString(value)) {\n      transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g, (match, functionName, args) => {\n        try {\n          const func = this.injector.get(functionName);\n          return func.transpile(...getFunctionArgs(args));\n        } catch (e) {\n          let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n\n          if (e.message.includes('NullInjectorError')) {\n            message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n          }\n\n          throw new Error(message);\n        }\n      });\n    }\n\n    return super.transpile(transpiled, params, translation);\n  }\n\n}\n\nFunctionalTranspiler.ɵfac = function FunctionalTranspiler_Factory(t) {\n  return new (t || FunctionalTranspiler)(i0.ɵɵinject(i0.Injector));\n};\n\nFunctionalTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FunctionalTranspiler,\n  factory: FunctionalTranspiler.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FunctionalTranspiler, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.Injector\n    }];\n  }, null);\n})();\n\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\n\nclass DefaultHandler {\n  handle(key, config) {\n    if (config.missingHandler.logMissingKey && !config.prodMode) {\n      const msg = `Missing translation for '${key}'`;\n      console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n    }\n\n    return key;\n  }\n\n}\n\nDefaultHandler.ɵfac = function DefaultHandler_Factory(t) {\n  return new (t || DefaultHandler)();\n};\n\nDefaultHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultHandler,\n  factory: DefaultHandler.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultHandler, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\n\nclass DefaultInterceptor {\n  preSaveTranslation(translation) {\n    return translation;\n  }\n\n  preSaveTranslationKey(_, value) {\n    return value;\n  }\n\n}\n\nDefaultInterceptor.ɵfac = function DefaultInterceptor_Factory(t) {\n  return new (t || DefaultInterceptor)();\n};\n\nDefaultInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultInterceptor,\n  factory: DefaultInterceptor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultInterceptor, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\n\nclass DefaultFallbackStrategy {\n  constructor(userConfig) {\n    this.userConfig = userConfig;\n  }\n\n  getNextLangs() {\n    const fallbackLang = this.userConfig.fallbackLang;\n\n    if (!fallbackLang) {\n      throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n    }\n\n    return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n  }\n\n}\n\nDefaultFallbackStrategy.ɵfac = function DefaultFallbackStrategy_Factory(t) {\n  return new (t || DefaultFallbackStrategy)(i0.ɵɵinject(TRANSLOCO_CONFIG));\n};\n\nDefaultFallbackStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultFallbackStrategy,\n  factory: DefaultFallbackStrategy.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultFallbackStrategy, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\nfunction mergeConfig(defaultConfig, userConfig) {\n  return Object.assign(Object.assign(Object.assign({}, defaultConfig), userConfig), {\n    missingHandler: Object.assign(Object.assign({}, defaultConfig.missingHandler), userConfig.missingHandler),\n    flatten: Object.assign(Object.assign({}, defaultConfig.flatten), userConfig.flatten)\n  });\n}\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\n\n\nfunction getScopeFromLang(lang) {\n  if (!lang) {\n    return '';\n  }\n\n  const split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\n\n\nfunction getLangFromScope(lang) {\n  if (!lang) {\n    return '';\n  }\n\n  return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\n\n\nfunction getPipeValue(str, value, char = '|') {\n  if (isString(str)) {\n    const splitted = str.split(char);\n    const lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n\n  return [false, ''];\n}\n\nfunction shouldListenToLangChanges(service, lang) {\n  const [hasStatic] = getPipeValue(lang, 'static');\n\n  if (!hasStatic) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return !!service.config.reRenderOnLangChange;\n  } // We have 'lang|static' so don't listen to lang changes\n\n\n  return false;\n}\n\nfunction listenOrNotOperator(listenToLangChange) {\n  return listenToLangChange ? source => source : take(1);\n}\n\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce((acc, lang) => {\n    acc[`${scope}/${lang}`] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\n\nfunction resolveInlineLoader(providerScope, scope) {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : undefined;\n}\n\nfunction getEventPayload(lang) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang)\n  };\n}\n\nfunction resolveLoader(options) {\n  const {\n    path,\n    inlineLoader,\n    mainLoader,\n    data\n  } = options;\n\n  if (inlineLoader) {\n    const pathLoader = inlineLoader[path];\n\n    if (isFunction(pathLoader) === false) {\n      throw `You're using an inline loader but didn't provide a loader for ${path}`;\n    }\n\n    return inlineLoader[path]().then(res => res.default ? res.default : res);\n  }\n\n  return mainLoader.getTranslation(path, data);\n}\n\nfunction getFallbacksLoaders({\n  mainLoader,\n  path,\n  data,\n  fallbackPath,\n  inlineLoader\n}) {\n  const paths = fallbackPath ? [path, fallbackPath] : [path];\n  return paths.map(path => {\n    const loader = resolveLoader({\n      path,\n      mainLoader,\n      inlineLoader,\n      data\n    });\n    return from(loader).pipe(map(translation => ({\n      translation,\n      lang: path\n    })));\n  });\n}\n\nlet service;\n\nfunction translate(key, params = {}, lang) {\n  return service.translate(key, params, lang);\n}\n\nclass TranslocoService {\n  constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n    this.loader = loader;\n    this.parser = parser;\n    this.missingHandler = missingHandler;\n    this.interceptor = interceptor;\n    this.userConfig = userConfig;\n    this.fallbackStrategy = fallbackStrategy;\n    this.subscription = null;\n    this.translations = new Map();\n    this.cache = new Map();\n    this.defaultLang = '';\n    this.availableLangs = [];\n    this.isResolvedMissingOnce = false;\n    this.failedLangs = new Set();\n    this.events = new Subject();\n    this.events$ = this.events.asObservable();\n\n    if (!this.loader) {\n      this.loader = new DefaultLoader(this.translations);\n    }\n\n    service = this;\n    this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);\n    this.setAvailableLangs(this.mergedConfig.availableLangs || []);\n    this.setFallbackLangForMissingTranslation(this.mergedConfig);\n    this.setDefaultLang(this.mergedConfig.defaultLang);\n    this.lang = new BehaviorSubject(this.getDefaultLang()); // Don't use distinctUntilChanged as we need the ability to update\n    // the value when using setTranslation or setTranslationKeys\n\n    this.langChanges$ = this.lang.asObservable();\n    /**\n     * When we have a failure, we want to define the next language that succeeded as the active\n     */\n\n    this.subscription = this.events$.subscribe(e => {\n      if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n        this.setActiveLang(e.payload.langName);\n      }\n    });\n  }\n\n  get config() {\n    return this.mergedConfig;\n  }\n\n  getDefaultLang() {\n    return this.defaultLang;\n  }\n\n  setDefaultLang(lang) {\n    this.defaultLang = lang;\n  }\n\n  getActiveLang() {\n    return this.lang.getValue();\n  }\n\n  setActiveLang(lang) {\n    var _a, _b;\n\n    this.lang.next(lang);\n    (_b = (_a = this.parser).onLangChanged) === null || _b === void 0 ? void 0 : _b.call(_a, lang);\n    return this;\n  }\n\n  setAvailableLangs(langs) {\n    this.availableLangs = langs;\n  }\n  /**\n   * Gets the available languages.\n   *\n   * @returns\n   * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n   * depending on how the available languages are set in your module.\n   */\n\n\n  getAvailableLangs() {\n    return this.availableLangs;\n  }\n\n  load(path, options = {}) {\n    const cached = this.cache.get(path);\n\n    if (cached) {\n      return cached;\n    }\n\n    let loadTranslation;\n\n    const isScope = this._isLangScoped(path);\n\n    let scope;\n\n    if (isScope) {\n      scope = getScopeFromLang(path);\n    }\n\n    const loadersOptions = {\n      path,\n      mainLoader: this.loader,\n      inlineLoader: options.inlineLoader,\n      data: isScope ? {\n        scope: scope\n      } : undefined\n    };\n\n    if (this.useFallbackTranslation(path)) {\n      // if the path is scope the fallback should be `scope/fallbackLang`;\n      const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;\n      const loaders = getFallbacksLoaders(Object.assign(Object.assign({}, loadersOptions), {\n        fallbackPath: fallback\n      }));\n      loadTranslation = forkJoin(loaders);\n    } else {\n      const loader = resolveLoader(loadersOptions);\n      loadTranslation = from(loader);\n    }\n\n    const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap(translation => {\n      if (Array.isArray(translation)) {\n        translation.forEach(t => {\n          this.handleSuccess(t.lang, t.translation); // Save the fallback in cache so we'll not create a redundant request\n\n          if (t.lang !== path) {\n            this.cache.set(t.lang, of({}));\n          }\n        });\n        return;\n      }\n\n      this.handleSuccess(path, translation);\n    }), catchError(error => {\n      if (!this.mergedConfig.prodMode) {\n        console.error(`Error while trying to load \"${path}\"`, error);\n      }\n\n      return this.handleFailure(path, options);\n    }), shareReplay(1));\n    this.cache.set(path, load$);\n    return load$;\n  }\n  /**\n   * Gets the instant translated value of a key\n   *\n   * @example\n   *\n   * translate<string>('hello')\n   * translate('hello', { value: 'value' })\n   * translate<string[]>(['hello', 'key'])\n   * translate('hello', { }, 'en')\n   * translate('scope.someKey', { }, 'en')\n   */\n\n\n  translate(key, params = {}, lang = this.getActiveLang()) {\n    if (!key) return key;\n    const {\n      scope,\n      resolveLang\n    } = this.resolveLangAndScope(lang);\n\n    if (Array.isArray(key)) {\n      return key.map(k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n    }\n\n    key = scope ? `${scope}.${key}` : key;\n    const translation = this.getTranslation(resolveLang);\n    const value = translation[key];\n\n    if (!value) {\n      return this._handleMissingKey(key, value, params);\n    }\n\n    return this.parser.transpile(value, params, translation);\n  }\n  /**\n   * Gets the translated value of a key as observable\n   *\n   * @example\n   *\n   * selectTranslate<string>('hello').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n   *\n   */\n\n\n  selectTranslate(key, params, lang, _isObject = false) {\n    let inlineLoader;\n\n    const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang)));\n\n    if (isNil(lang)) {\n      return this.langChanges$.pipe(switchMap(lang => load(lang)));\n    }\n\n    if (isScopeObject(lang)) {\n      // it's a scope object.\n      const providerScope = lang;\n      lang = providerScope.scope;\n      inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n    }\n\n    lang = lang;\n\n    if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n      return load(lang);\n    } // it's a scope\n\n\n    const scope = lang;\n    return this.langChanges$.pipe(switchMap(lang => load(`${scope}/${lang}`, {\n      inlineLoader\n    })));\n  }\n  /**\n   * Whether the scope with lang\n   *\n   * @example\n   *\n   * todos/en => true\n   * todos => false\n   */\n\n\n  isScopeWithLang(lang) {\n    return this.isLang(getLangFromScope(lang));\n  }\n\n  translateObject(key, params = {}, lang = this.getActiveLang()) {\n    if (isString(key) || Array.isArray(key)) {\n      if (Array.isArray(key)) {\n        return key.map(k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n      }\n\n      const {\n        resolveLang,\n        scope\n      } = this.resolveLangAndScope(lang);\n      const translation = this.getTranslation(resolveLang);\n      key = scope ? `${scope}.${key}` : key;\n      const value = unflatten(this.getObjectByKey(translation, key));\n      /* If an empty object was returned we want to try and translate the key as a string and not an object */\n\n      return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);\n    }\n\n    const translations = [];\n\n    for (const [_key, _params] of this.getEntries(key)) {\n      translations.push(this.translateObject(_key, _params, lang));\n    }\n\n    return translations;\n  }\n\n  selectTranslateObject(key, params, lang) {\n    if (isString(key) || Array.isArray(key)) {\n      return this.selectTranslate(key, params, lang, true);\n    }\n\n    const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n    /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n     * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n\n    return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map(value => {\n      const translations = [value];\n\n      for (const [_key, _params] of rest) {\n        translations.push(this.translateObject(_key, _params, lang));\n      }\n\n      return translations;\n    }));\n  }\n\n  getTranslation(langOrScope) {\n    if (langOrScope) {\n      if (this.isLang(langOrScope)) {\n        return this.translations.get(langOrScope) || {};\n      } else {\n        // This is a scope, build the scope value from the translation object\n        const {\n          scope,\n          resolveLang\n        } = this.resolveLangAndScope(langOrScope);\n        const translation = this.translations.get(resolveLang) || {};\n        return this.getObjectByKey(translation, scope);\n      }\n    }\n\n    return this.translations;\n  }\n  /**\n   * Gets an object of translations for a given language\n   *\n   * @example\n   *\n   * selectTranslation().subscribe() - will return the current lang translation\n   * selectTranslation('es').subscribe()\n   * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n   * selectTranslation('admin-page/es').subscribe()\n   */\n\n\n  selectTranslation(lang) {\n    let language$ = this.langChanges$;\n\n    if (lang) {\n      const scopeLangSpecified = getLangFromScope(lang) !== lang;\n\n      if (this.isLang(lang) || scopeLangSpecified) {\n        language$ = of(lang);\n      } else {\n        language$ = this.langChanges$.pipe(map(currentLang => `${lang}/${currentLang}`));\n      }\n    }\n\n    return language$.pipe(switchMap(language => this.load(language).pipe(map(() => this.getTranslation(language)))));\n  }\n  /**\n   * Sets or merge a given translation object to current lang\n   *\n   * @example\n   *\n   * setTranslation({ ... })\n   * setTranslation({ ... }, 'en')\n   * setTranslation({ ... }, 'es', { merge: false } )\n   * setTranslation({ ... }, 'todos/en', { merge: false } )\n   */\n\n\n  setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n    const defaults = {\n      merge: true,\n      emitChange: true\n    };\n    const mergedOptions = Object.assign(Object.assign({}, defaults), options);\n    const scope = getScopeFromLang(lang);\n    /**\n     * If this isn't a scope we use the whole translation as is\n     * otherwise we need to flat the scope and use it\n     */\n\n    let flattenScopeOrTranslation = translation; // Merged the scoped language into the active language\n\n    if (scope) {\n      const key = this.getMappedScope(scope);\n      flattenScopeOrTranslation = flatten({\n        [key]: translation\n      });\n    }\n\n    const currentLang = scope ? getLangFromScope(lang) : lang;\n    const mergedTranslation = Object.assign(Object.assign({}, mergedOptions.merge && this.getTranslation(currentLang)), flattenScopeOrTranslation);\n    const flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n    const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n    this.translations.set(currentLang, withHook);\n    mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n  }\n  /**\n   * Sets translation key with given value\n   *\n   * @example\n   *\n   * setTranslationKey('key', 'value')\n   * setTranslationKey('key.nested', 'value')\n   * setTranslationKey('key.nested', 'value', 'en')\n   * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n   */\n\n\n  setTranslationKey(key, value, // Todo: Add the lang to the options in v3\n  lang = this.getActiveLang(), options = {}) {\n    const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n    const newValue = {\n      [key]: withHook\n    };\n    this.setTranslation(newValue, lang, Object.assign(Object.assign({}, options), {\n      merge: true\n    }));\n  }\n  /**\n   * Sets the fallback lang for the currently active language\n   * @param fallbackLang\n   */\n\n\n  setFallbackLangForMissingTranslation({\n    fallbackLang\n  }) {\n    const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n\n    if (fallbackLang && this.useFallbackTranslation(lang)) {\n      this.firstFallbackLang = lang;\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  _handleMissingKey(key, value, params) {\n    if (this.config.missingHandler.allowEmpty && value === '') {\n      return '';\n    }\n\n    if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n      // We need to set it to true to prevent a loop\n      this.isResolvedMissingOnce = true;\n      const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n      this.isResolvedMissingOnce = false;\n      return fallbackValue;\n    }\n\n    return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n  }\n  /**\n   * @internal\n   */\n\n\n  _isLangScoped(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) === -1;\n  }\n  /**\n   * Checks if a given string is one of the specified available languages.\n   * @returns\n   * True if the given string is an available language.\n   * False if the given string is not an available language.\n   */\n\n\n  isLang(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) !== -1;\n  }\n  /**\n   * @internal\n   *\n   * We always want to make sure the global lang is loaded\n   * before loading the scope since you can access both via the pipe/directive.\n   */\n\n\n  _loadDependencies(path, inlineLoader) {\n    const mainLang = getLangFromScope(path);\n\n    if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n      return combineLatest(this.load(mainLang), this.load(path, {\n        inlineLoader\n      }));\n    }\n\n    return this.load(path, {\n      inlineLoader\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  _completeScopeWithLang(langOrScope) {\n    if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n      return `${langOrScope}/${this.getActiveLang()}`;\n    }\n\n    return langOrScope;\n  }\n  /**\n   * @internal\n   */\n\n\n  _setScopeAlias(scope, alias) {\n    if (!this.mergedConfig.scopeMapping) {\n      this.mergedConfig.scopeMapping = {};\n    }\n\n    this.mergedConfig.scopeMapping[scope] = alias;\n  }\n\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n\n      this.subscription = null;\n    } // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n    // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n    // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n    // and destroyed per each HTTP request, but any service is not getting GC'd.\n\n\n    this.cache.clear();\n  }\n\n  isLoadedTranslation(lang) {\n    return size(this.getTranslation(lang));\n  }\n\n  getAvailableLangsIds() {\n    const first = this.getAvailableLangs()[0];\n\n    if (isString(first)) {\n      return this.getAvailableLangs();\n    }\n\n    return this.getAvailableLangs().map(l => l.id);\n  }\n\n  getMissingHandlerData() {\n    return Object.assign(Object.assign({}, this.config), {\n      activeLang: this.getActiveLang(),\n      availableLangs: this.availableLangs,\n      defaultLang: this.defaultLang\n    });\n  }\n  /**\n   * Use a fallback translation set for missing keys of the primary language\n   * This is unrelated to the fallback language (which changes the active language)\n   */\n\n\n  useFallbackTranslation(lang) {\n    return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n  }\n\n  handleSuccess(lang, translation) {\n    this.setTranslation(translation, lang, {\n      emitChange: false\n    });\n    this.events.next({\n      wasFailure: !!this.failedLangs.size,\n      type: 'translationLoadSuccess',\n      payload: getEventPayload(lang)\n    });\n    this.failedLangs.forEach(l => this.cache.delete(l));\n    this.failedLangs.clear();\n  }\n\n  handleFailure(lang, loadOptions) {\n    // When starting to load a first choice language, initialize\n    // the failed counter and resolve the fallback langs.\n    if (isNil(loadOptions.failedCounter)) {\n      loadOptions.failedCounter = 0;\n\n      if (!loadOptions.fallbackLangs) {\n        loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n      }\n    }\n\n    const splitted = lang.split('/');\n    const fallbacks = loadOptions.fallbackLangs;\n    const nextLang = fallbacks[loadOptions.failedCounter];\n    this.failedLangs.add(lang); // This handles the case where a loaded fallback language is requested again\n\n    if (this.cache.has(nextLang)) {\n      this.handleSuccess(nextLang, this.getTranslation(nextLang));\n      return EMPTY;\n    }\n\n    const isFallbackLang = nextLang === splitted[splitted.length - 1];\n\n    if (!nextLang || isFallbackLang) {\n      let msg = `Unable to load translation and all the fallback languages`;\n\n      if (splitted.length > 1) {\n        msg += `, did you misspelled the scope name?`;\n      }\n\n      throw new Error(msg);\n    }\n\n    let resolveLang = nextLang; // if it's scoped lang\n\n    if (splitted.length > 1) {\n      // We need to resolve it to:\n      // todos/langNotExists => todos/nextLang\n      splitted[splitted.length - 1] = nextLang;\n      resolveLang = splitted.join('/');\n    }\n\n    loadOptions.failedCounter++;\n    this.events.next({\n      type: 'translationLoadFailure',\n      payload: getEventPayload(lang)\n    });\n    return this.load(resolveLang, loadOptions);\n  }\n\n  getMappedScope(scope) {\n    const {\n      scopeMapping = {}\n    } = this.config;\n    return scopeMapping[scope] || toCamelCase(scope);\n  }\n  /**\n   * If lang is scope we need to check the following cases:\n   * todos/es => in this case we should take `es` as lang\n   * todos => in this case we should set the active lang as lang\n   */\n\n\n  resolveLangAndScope(lang) {\n    let resolveLang = lang;\n    let scope;\n\n    if (this._isLangScoped(lang)) {\n      // en for example\n      const langFromScope = getLangFromScope(lang); // en is lang\n\n      const hasLang = this.isLang(langFromScope); // take en\n\n      resolveLang = hasLang ? langFromScope : this.getActiveLang(); // find the scope\n\n      scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n    }\n\n    return {\n      scope,\n      resolveLang\n    };\n  }\n\n  getObjectByKey(translation, key) {\n    const result = {};\n    const prefix = `${key}.`;\n\n    for (const currentKey in translation) {\n      if (currentKey.startsWith(prefix)) {\n        result[currentKey.replace(prefix, '')] = translation[currentKey];\n      }\n    }\n\n    return result;\n  }\n\n  getEntries(key) {\n    return key instanceof Map ? key.entries() : Object.entries(key);\n  }\n\n}\n\nTranslocoService.ɵfac = function TranslocoService_Factory(t) {\n  return new (t || TranslocoService)(i0.ɵɵinject(TRANSLOCO_LOADER, 8), i0.ɵɵinject(TRANSLOCO_TRANSPILER), i0.ɵɵinject(TRANSLOCO_MISSING_HANDLER), i0.ɵɵinject(TRANSLOCO_INTERCEPTOR), i0.ɵɵinject(TRANSLOCO_CONFIG), i0.ɵɵinject(TRANSLOCO_FALLBACK_STRATEGY));\n};\n\nTranslocoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TranslocoService,\n  factory: TranslocoService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LOADER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_TRANSPILER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_MISSING_HANDLER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_INTERCEPTOR]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_FALLBACK_STRATEGY]\n      }]\n    }];\n  }, null);\n})();\n\nclass TranslocoLoaderComponent {}\n\nTranslocoLoaderComponent.ɵfac = function TranslocoLoaderComponent_Factory(t) {\n  return new (t || TranslocoLoaderComponent)();\n};\n\nTranslocoLoaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: TranslocoLoaderComponent,\n  selectors: [[\"ng-component\"]],\n  inputs: {\n    html: \"html\"\n  },\n  decls: 1,\n  vars: 1,\n  consts: [[1, \"transloco-loader-template\", 3, \"innerHTML\"]],\n  template: function TranslocoLoaderComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelement(0, \"div\", 0);\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"innerHTML\", ctx.html, i0.ɵɵsanitizeHtml);\n    }\n  },\n  encapsulation: 2\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoLoaderComponent, [{\n    type: Component,\n    args: [{\n      template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `\n    }]\n  }], null, {\n    html: [{\n      type: Input\n    }]\n  });\n})();\n\nclass TemplateHandler {\n  constructor(view, vcr) {\n    this.view = view;\n    this.vcr = vcr;\n    this.injector = this.vcr.injector;\n  }\n\n  attachView() {\n    if (this.view instanceof TemplateRef) {\n      this.vcr.createEmbeddedView(this.view);\n    } else if (isString(this.view)) {\n      const componentRef = this.createComponent(TranslocoLoaderComponent);\n      componentRef.instance.html = this.view;\n      componentRef.hostView.detectChanges();\n    } else {\n      this.createComponent(this.view);\n    }\n  }\n\n  detachView() {\n    this.vcr.clear();\n  }\n\n  createComponent(cmp) {\n    const cfr = this.injector.get(ComponentFactoryResolver);\n    const factory = cfr.resolveComponentFactory(cmp);\n    return this.vcr.createComponent(factory);\n  }\n\n}\n\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\nclass LangResolver {\n  constructor() {\n    this.initialized = false;\n  } // inline => provider => active\n\n\n  resolve({\n    inline,\n    provider,\n    active\n  }) {\n    let lang = active;\n    /**\n     * When the user changes the lang we need to update\n     * the view. Otherwise, the lang will remain the inline/provided lang\n     */\n\n    if (this.initialized) {\n      lang = active;\n      return lang;\n    }\n\n    if (provider) {\n      const [, extracted] = getPipeValue(provider, 'static');\n      lang = extracted;\n    }\n\n    if (inline) {\n      const [, extracted] = getPipeValue(inline, 'static');\n      lang = extracted;\n    }\n\n    this.initialized = true;\n    return lang;\n  }\n  /**\n   *\n   * Resolve the lang\n   *\n   * @example\n   *\n   * resolveLangBasedOnScope('todos/en') => en\n   * resolveLangBasedOnScope('en') => en\n   *\n   */\n\n\n  resolveLangBasedOnScope(lang) {\n    const scope = getScopeFromLang(lang);\n    return scope ? getLangFromScope(lang) : lang;\n  }\n  /**\n   *\n   * Resolve the lang path for loading\n   *\n   * @example\n   *\n   * resolveLangPath('todos', 'en') => todos/en\n   * resolveLangPath('en') => en\n   *\n   */\n\n\n  resolveLangPath(lang, scope) {\n    return scope ? `${scope}/${lang}` : lang;\n  }\n\n}\n\nclass ScopeResolver {\n  constructor(translocoService) {\n    this.translocoService = translocoService;\n  } // inline => provider\n\n\n  resolve({\n    inline,\n    provider\n  } = {\n    inline: undefined,\n    provider: undefined\n  }) {\n    if (inline) {\n      return inline;\n    }\n\n    if (provider) {\n      if (isScopeObject(provider)) {\n        const {\n          scope,\n          alias = toCamelCase(scope)\n        } = provider;\n\n        this.translocoService._setScopeAlias(scope, alias);\n\n        return scope;\n      }\n\n      return provider;\n    }\n\n    return undefined;\n  }\n\n}\n\nclass TranslocoDirective {\n  constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host) {\n    this.translocoService = translocoService;\n    this.tpl = tpl;\n    this.providerScope = providerScope;\n    this.providerLang = providerLang;\n    this.providedLoadingTpl = providedLoadingTpl;\n    this.vcr = vcr;\n    this.cdr = cdr;\n    this.host = host;\n    this.subscription = null;\n    this.translationMemo = {};\n    this.params = {}; // Whether we already rendered the view once\n\n    this.initialized = false;\n    this.langResolver = new LangResolver();\n    this.scopeResolver = new ScopeResolver(this.translocoService);\n  }\n\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n\n  ngOnInit() {\n    const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n    this.subscription = this.translocoService.langChanges$.pipe(switchMap(activeLang => {\n      const lang = this.langResolver.resolve({\n        inline: this.inlineLang,\n        provider: this.providerLang,\n        active: activeLang\n      });\n      return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n    }), listenOrNotOperator(listenToLangChange)).subscribe(() => {\n      this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n      this.tpl === null ? this.simpleStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n      this.cdr.markForCheck();\n      this.initialized = true;\n    });\n    const loadingTpl = this.getLoadingTpl();\n\n    if (!this.initialized && loadingTpl) {\n      this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n      this.loaderTplHandler.attachView();\n    }\n  }\n\n  ngOnChanges(changes) {\n    // We need to support dynamic keys/params, so if this is not the first change CD cycle\n    // we need to run the function again in order to update the value\n    const notInit = Object.keys(changes).some(v => !changes[v].firstChange);\n    notInit && this.simpleStrategy();\n  }\n\n  simpleStrategy() {\n    this.detachLoader();\n    this.host.nativeElement.innerText = this.translocoService.translate(this.key, this.params, this.currentLang);\n  }\n\n  structuralStrategy(lang, read) {\n    this.translationMemo = {};\n\n    if (this.view) {\n      // when the lang changes we need to change the reference so Angular will update the view\n      this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n      this.view.context['currentLang'] = this.currentLang;\n    } else {\n      this.detachLoader();\n      this.view = this.vcr.createEmbeddedView(this.tpl, {\n        $implicit: this.getTranslateFn(lang, read),\n        currentLang: this.currentLang\n      });\n    }\n  }\n\n  getTranslateFn(lang, read) {\n    return (key, params) => {\n      const withRead = read ? `${read}.${key}` : key;\n      const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n\n      if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n        return this.translationMemo[withParams].value;\n      }\n\n      this.translationMemo[withParams] = {\n        params,\n        value: this.translocoService.translate(withRead, params, lang)\n      };\n      return this.translationMemo[withParams].value;\n    };\n  }\n\n  getLoadingTpl() {\n    return this.inlineTpl || this.providedLoadingTpl;\n  }\n\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n\n      this.subscription = null;\n    }\n  }\n\n  detachLoader() {\n    var _a;\n\n    (_a = this.loaderTplHandler) === null || _a === void 0 ? void 0 : _a.detachView();\n  }\n\n  resolveScope(lang, providerScope) {\n    const resolvedScope = this.scopeResolver.resolve({\n      inline: this.inlineScope,\n      provider: providerScope\n    });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n\n}\n\nTranslocoDirective.ɵfac = function TranslocoDirective_Factory(t) {\n  return new (t || TranslocoDirective)(i0.ɵɵdirectiveInject(TranslocoService), i0.ɵɵdirectiveInject(i0.TemplateRef, 8), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LOADING_TEMPLATE, 8), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nTranslocoDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: TranslocoDirective,\n  selectors: [[\"\", \"transloco\", \"\"]],\n  inputs: {\n    key: [\"transloco\", \"key\"],\n    params: [\"translocoParams\", \"params\"],\n    inlineScope: [\"translocoScope\", \"inlineScope\"],\n    inlineRead: [\"translocoRead\", \"inlineRead\"],\n    inlineLang: [\"translocoLang\", \"inlineLang\"],\n    inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"]\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[transloco]'\n    }]\n  }], function () {\n    return [{\n      type: TranslocoService\n    }, {\n      type: i0.TemplateRef,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_SCOPE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LANG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LOADING_TEMPLATE]\n      }]\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.ElementRef\n    }];\n  }, {\n    key: [{\n      type: Input,\n      args: ['transloco']\n    }],\n    params: [{\n      type: Input,\n      args: ['translocoParams']\n    }],\n    inlineScope: [{\n      type: Input,\n      args: ['translocoScope']\n    }],\n    inlineRead: [{\n      type: Input,\n      args: ['translocoRead']\n    }],\n    inlineLang: [{\n      type: Input,\n      args: ['translocoLang']\n    }],\n    inlineTpl: [{\n      type: Input,\n      args: ['translocoLoadingTpl']\n    }]\n  });\n})();\n\nclass TranslocoPipe {\n  constructor(translocoService, providerScope, providerLang, cdr) {\n    this.translocoService = translocoService;\n    this.providerScope = providerScope;\n    this.providerLang = providerLang;\n    this.cdr = cdr;\n    this.subscription = null;\n    this.lastValue = '';\n    this.langResolver = new LangResolver();\n    this.scopeResolver = new ScopeResolver(this.translocoService);\n  } // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n  // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n\n\n  transform(key, params, inlineLang) {\n    var _a;\n\n    if (!key) {\n      return key;\n    }\n\n    const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n\n    if (keyName === this.lastKey) {\n      return this.lastValue;\n    }\n\n    this.lastKey = keyName;\n    (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);\n    this.subscription = this.translocoService.langChanges$.pipe(switchMap(activeLang => {\n      const lang = this.langResolver.resolve({\n        inline: inlineLang,\n        provider: this.providerLang,\n        active: activeLang\n      });\n      return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n    }), listenOrNotOperator(listenToLangChange)).subscribe(() => this.updateValue(key, params));\n    return this.lastValue;\n  }\n\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe(); // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n\n      this.subscription = null;\n    }\n  }\n\n  updateValue(key, params) {\n    const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n    this.lastValue = this.translocoService.translate(key, params, lang);\n    this.cdr.markForCheck();\n  }\n\n  resolveScope(lang, providerScope) {\n    const resolvedScope = this.scopeResolver.resolve({\n      inline: undefined,\n      provider: providerScope\n    });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n\n}\n\nTranslocoPipe.ɵfac = function TranslocoPipe_Factory(t) {\n  return new (t || TranslocoPipe)(i0.ɵɵdirectiveInject(TranslocoService, 16), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 24), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 24), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n};\n\nTranslocoPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n  name: \"transloco\",\n  type: TranslocoPipe,\n  pure: false\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'transloco',\n      pure: false\n    }]\n  }], function () {\n    return [{\n      type: TranslocoService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_SCOPE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LANG]\n      }]\n    }, {\n      type: i0.ChangeDetectorRef\n    }];\n  }, null);\n})();\n\nconst defaultProviders = [{\n  provide: TRANSLOCO_TRANSPILER,\n  useClass: DefaultTranspiler,\n  deps: [TRANSLOCO_CONFIG]\n}, {\n  provide: TRANSLOCO_MISSING_HANDLER,\n  useClass: DefaultHandler\n}, {\n  provide: TRANSLOCO_INTERCEPTOR,\n  useClass: DefaultInterceptor\n}, {\n  provide: TRANSLOCO_FALLBACK_STRATEGY,\n  useClass: DefaultFallbackStrategy,\n  deps: [TRANSLOCO_CONFIG]\n}];\n\nclass TranslocoModule {}\n\nTranslocoModule.ɵfac = function TranslocoModule_Factory(t) {\n  return new (t || TranslocoModule)();\n};\n\nTranslocoModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: TranslocoModule\n});\nTranslocoModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [defaultProviders]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n      providers: [defaultProviders],\n      exports: [TranslocoDirective, TranslocoPipe],\n      entryComponents: [TranslocoLoaderComponent]\n    }]\n  }], null, null);\n})();\n\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\n\nclass TestingLoader {\n  constructor(langs) {\n    this.langs = langs;\n  }\n\n  getTranslation(lang) {\n    return of(this.langs[lang]);\n  }\n\n}\n\nTestingLoader.ɵfac = function TestingLoader_Factory(t) {\n  return new (t || TestingLoader)(i0.ɵɵinject(TRANSLOCO_TEST_LANGS));\n};\n\nTestingLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TestingLoader,\n  factory: TestingLoader.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TestingLoader, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_TEST_LANGS]\n      }]\n    }];\n  }, null);\n})();\n\nfunction initTranslocoService(service, langs = {}, options) {\n  const preloadAllLangs = () => options.preloadLangs ? Promise.all(Object.keys(langs).map(lang => service.load(lang).toPromise())) : Promise.resolve();\n\n  return preloadAllLangs;\n}\n\nclass TranslocoTestingModule {\n  static forRoot(options) {\n    return {\n      ngModule: TranslocoTestingModule,\n      providers: [{\n        provide: TRANSLOCO_TEST_LANGS,\n        useValue: options.langs\n      }, {\n        provide: TRANSLOCO_TEST_OPTIONS,\n        useValue: options\n      }, {\n        provide: APP_INITIALIZER,\n        useFactory: initTranslocoService,\n        deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n        multi: true\n      }, {\n        provide: TRANSLOCO_LOADER,\n        useClass: TestingLoader\n      }, defaultProviders, {\n        provide: TRANSLOCO_CONFIG,\n        useValue: translocoConfig(Object.assign({\n          prodMode: true,\n          missingHandler: {\n            logMissingKey: false\n          }\n        }, options.translocoConfig))\n      }]\n    };\n  }\n\n}\n\nTranslocoTestingModule.ɵfac = function TranslocoTestingModule_Factory(t) {\n  return new (t || TranslocoTestingModule)();\n};\n\nTranslocoTestingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: TranslocoTestingModule\n});\nTranslocoTestingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [TranslocoModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoTestingModule, [{\n    type: NgModule,\n    args: [{\n      exports: [TranslocoModule]\n    }]\n  }], null, null);\n})();\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\n\n\nfunction getBrowserLang() {\n  let browserLang = getBrowserCultureLang();\n\n  if (!browserLang || !isBrowser()) {\n    return undefined;\n  }\n\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n\n  return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\n\n\nfunction getBrowserCultureLang() {\n  if (!isBrowser()) {\n    return '';\n  }\n\n  const navigator = window.navigator;\n  let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n  browserCultureLang = browserCultureLang || navigator.language || navigator.browserLanguage || navigator.userLanguage;\n  return browserCultureLang;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TemplateHandler, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, defaultProviders, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeObject, isString, setValue, size, toCamelCase, toNumber, translate, translocoConfig, unflatten };","map":{"version":3,"sources":["C:/Users/Kalsym/Desktop/Angular/fuse-starter/node_modules/@ngneat/transloco/fesm2015/ngneat-transloco.js"],"names":["i0","InjectionToken","Injectable","Optional","Inject","Component","Input","TemplateRef","ComponentFactoryResolver","Directive","Pipe","NgModule","APP_INITIALIZER","of","from","Subject","BehaviorSubject","forkJoin","combineLatest","EMPTY","take","map","retry","tap","catchError","shareReplay","switchMap","unflatten","unflatten$1","flatten","flatten$1","DefaultLoader","constructor","translations","getTranslation","lang","get","TRANSLOCO_LOADER","getValue","obj","path","Object","prototype","hasOwnProperty","call","split","reduce","p","c","setValue","prop","val","assign","lastIndex","length","acc","part","index","Array","isArray","slice","size","collection","isObject","keys","isEmpty","isFunction","isString","isNumber","item","coerceArray","value","toCamelCase","str","replace","word","toLowerCase","toUpperCase","isBrowser","window","isNil","undefined","isDefined","toNumber","isNaN","Number","parseFloat","isScopeObject","scope","hasInlineLoader","loader","safe","TRANSLOCO_CONFIG","providedIn","factory","defaultLang","defaultConfig","reRenderOnLangChange","prodMode","failedRetries","availableLangs","missingHandler","logMissingKey","useFallbackTranslation","allowEmpty","aot","interpolation","translocoConfig","config","TRANSLOCO_TRANSPILER","DefaultTranspiler","userConfig","interpolationMatcher","resolveMatcher","transpile","params","translation","_","match","trim","handleObject","handleArray","result","forEach","v","getParams","transpiled","ɵfac","ɵprov","type","decorators","args","start","end","RegExp","getFunctionArgs","argsString","splitted","i","push","FunctionalTranspiler","injector","functionName","func","e","message","includes","Error","Injector","TRANSLOCO_MISSING_HANDLER","DefaultHandler","handle","key","msg","console","warn","TRANSLOCO_INTERCEPTOR","DefaultInterceptor","preSaveTranslation","preSaveTranslationKey","TRANSLOCO_FALLBACK_STRATEGY","DefaultFallbackStrategy","getNextLangs","fallbackLang","mergeConfig","getScopeFromLang","pop","join","getLangFromScope","getPipeValue","char","lastItem","toString","shouldListenToLangChanges","service","hasStatic","listenOrNotOperator","listenToLangChange","source","prependScope","inlineLoader","resolveInlineLoader","providerScope","getEventPayload","langName","resolveLoader","options","mainLoader","data","pathLoader","then","res","default","getFallbacksLoaders","fallbackPath","paths","pipe","translate","TranslocoService","parser","interceptor","fallbackStrategy","subscription","Map","cache","isResolvedMissingOnce","failedLangs","Set","events","events$","asObservable","mergedConfig","setAvailableLangs","setFallbackLangForMissingTranslation","setDefaultLang","getDefaultLang","langChanges$","subscribe","wasFailure","setActiveLang","payload","getActiveLang","_a","_b","next","onLangChanged","langs","getAvailableLangs","load","cached","loadTranslation","isScope","_isLangScoped","loadersOptions","fallback","firstFallbackLang","loaders","load$","t","handleSuccess","set","error","handleFailure","resolveLang","resolveLangAndScope","k","_handleMissingKey","selectTranslate","_isObject","translateObject","isLang","isScopeWithLang","getObjectByKey","_key","_params","getEntries","selectTranslateObject","firstKey","firstParams","rest","langOrScope","selectTranslation","language$","scopeLangSpecified","currentLang","language","setTranslation","defaults","merge","emitChange","mergedOptions","flattenScopeOrTranslation","getMappedScope","mergedTranslation","flattenTranslation","withHook","setTranslationKey","newValue","fallbackValue","getMissingHandlerData","getAvailableLangsIds","indexOf","_loadDependencies","mainLang","isLoadedTranslation","_completeScopeWithLang","_setScopeAlias","alias","scopeMapping","ngOnDestroy","unsubscribe","clear","first","l","id","activeLang","delete","loadOptions","failedCounter","fallbackLangs","fallbacks","nextLang","add","has","isFallbackLang","langFromScope","hasLang","prefix","currentKey","startsWith","entries","TranslocoLoaderComponent","ɵcmp","template","html","TemplateHandler","view","vcr","attachView","createEmbeddedView","componentRef","createComponent","instance","hostView","detectChanges","detachView","cmp","cfr","resolveComponentFactory","TRANSLOCO_LANG","TRANSLOCO_LOADING_TEMPLATE","TRANSLOCO_SCOPE","LangResolver","initialized","resolve","inline","provider","active","extracted","resolveLangBasedOnScope","resolveLangPath","ScopeResolver","translocoService","TranslocoDirective","tpl","providerLang","providedLoadingTpl","cdr","host","translationMemo","langResolver","scopeResolver","ngTemplateContextGuard","dir","ctx","ngOnInit","inlineLang","resolveScope","simpleStrategy","structuralStrategy","inlineRead","markForCheck","loadingTpl","getLoadingTpl","loaderTplHandler","ngOnChanges","changes","notInit","some","firstChange","detachLoader","nativeElement","innerText","read","context","getTranslateFn","$implicit","withRead","withParams","JSON","stringify","inlineTpl","resolvedScope","inlineScope","ViewContainerRef","ChangeDetectorRef","ElementRef","ɵdir","selector","TranslocoPipe","lastValue","transform","keyName","lastKey","updateValue","ɵpipe","name","pure","defaultProviders","provide","useClass","deps","TranslocoModule","ɵmod","ɵinj","declarations","providers","exports","entryComponents","TRANSLOCO_TEST_LANGS","TRANSLOCO_TEST_OPTIONS","TestingLoader","initTranslocoService","preloadAllLangs","preloadLangs","Promise","all","toPromise","TranslocoTestingModule","forRoot","ngModule","useValue","useFactory","multi","getBrowserLang","browserLang","getBrowserCultureLang","navigator","browserCultureLang","languages","browserLanguage","userLanguage"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, ComponentFactoryResolver, Directive, Pipe, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { of, from, Subject, BehaviorSubject, forkJoin, combineLatest, EMPTY } from 'rxjs';\nimport { take, map, retry, tap, catchError, shareReplay, switchMap } from 'rxjs/operators';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\n\nclass DefaultLoader {\n    constructor(translations) {\n        this.translations = translations;\n    }\n    getTranslation(lang) {\n        return of(this.translations.get(lang) || {});\n    }\n}\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\nfunction getValue(obj, path) {\n    if (!obj) {\n        return obj;\n    }\n    /* For cases where the key is like: 'general.something.thing' */\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n        return obj[path];\n    }\n    return path.split('.').reduce((p, c) => p === null || p === void 0 ? void 0 : p[c], obj);\n}\nfunction setValue(obj, prop, val) {\n    obj = Object.assign({}, obj);\n    const split = prop.split('.');\n    const lastIndex = split.length - 1;\n    split.reduce((acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part])\n                ? acc[part].slice()\n                : Object.assign({}, acc[part]);\n        }\n        return acc && acc[part];\n    }, obj);\n    return obj;\n}\nfunction size(collection) {\n    if (!collection) {\n        return 0;\n    }\n    if (Array.isArray(collection)) {\n        return collection.length;\n    }\n    if (isObject(collection)) {\n        return Object.keys(collection).length;\n    }\n    return collection ? collection.length : 0;\n}\nfunction isEmpty(collection) {\n    return size(collection) === 0;\n}\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\nfunction isString(val) {\n    return typeof val === 'string';\n}\nfunction isNumber(val) {\n    return typeof val === 'number';\n}\nfunction isObject(item) {\n    return !!item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\nfunction toCamelCase(str) {\n    return str\n        .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase())\n        .replace(/\\s+|_|-|\\//g, '');\n}\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\nfunction isNil(value) {\n    return value === null || value === undefined;\n}\nfunction isDefined(value) {\n    return isNil(value) === false;\n}\nfunction toNumber(value) {\n    if (isNumber(value))\n        return value;\n    if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n        return Number(value);\n    }\n    return null;\n}\nfunction isScopeObject(item) {\n    return item && typeof item.scope === 'string';\n}\nfunction hasInlineLoader(item) {\n    return item && isObject(item.loader);\n}\nfunction unflatten(obj) {\n    return unflatten$1(obj);\n}\nfunction flatten(obj) {\n    return flatten$1(obj, { safe: true });\n}\n\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n    providedIn: 'root',\n    factory: () => {\n        return { defaultLang: 'en' };\n    },\n});\nconst defaultConfig = {\n    defaultLang: 'en',\n    reRenderOnLangChange: false,\n    prodMode: false,\n    failedRetries: 2,\n    availableLangs: [],\n    missingHandler: {\n        logMissingKey: true,\n        useFallbackTranslation: false,\n        allowEmpty: false,\n    },\n    flatten: {\n        aot: false,\n    },\n    interpolation: ['{{', '}}'],\n};\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\nfunction translocoConfig(config = defaultConfig) {\n    return Object.assign(Object.assign({}, defaultConfig), config);\n}\n\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nclass DefaultTranspiler {\n    constructor(userConfig) {\n        this.interpolationMatcher = resolveMatcher(userConfig);\n    }\n    transpile(value, params = {}, translation) {\n        if (isString(value)) {\n            return value.replace(this.interpolationMatcher, (_, match) => {\n                match = match.trim();\n                if (isDefined(params[match])) {\n                    return params[match];\n                }\n                return isDefined(translation[match])\n                    ? this.transpile(translation[match], params, translation)\n                    : '';\n            });\n        }\n        else if (params) {\n            if (isObject(value)) {\n                value = this.handleObject(value, params, translation);\n            }\n            else if (Array.isArray(value)) {\n                value = this.handleArray(value, params, translation);\n            }\n        }\n        return value;\n    }\n    /**\n     *\n     * @example\n     *\n     * const en = {\n     *  a: {\n     *    b: {\n     *      c: \"Hello {{ value }}\"\n     *    }\n     *  }\n     * }\n     *\n     * const params =  {\n     *  \"b.c\": { value: \"Transloco \"}\n     * }\n     *\n     * service.selectTranslate('a', params);\n     *\n     * // the first param will be the result of `en.a`.\n     * // the second param will be `params`.\n     * parser.transpile(value, params, {});\n     *\n     *\n     */\n    handleObject(value, params = {}, translation) {\n        let result = value;\n        Object.keys(params).forEach((p) => {\n            // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n            const v = getValue(result, p);\n            // get the params of \"b.c\" => { value: \"Transloco\" }\n            const getParams = getValue(params, p);\n            // transpile the value => \"Hello Transloco\"\n            const transpiled = this.transpile(v, getParams, translation);\n            // set \"b.c\" to `transpiled`\n            result = setValue(result, p, transpiled);\n        });\n        return result;\n    }\n    handleArray(value, params = {}, translation) {\n        return value.map((v) => this.transpile(v, params, translation));\n    }\n}\nDefaultTranspiler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultTranspiler, deps: [{ token: TRANSLOCO_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultTranspiler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultTranspiler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultTranspiler, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }]; } });\nfunction resolveMatcher(userConfig) {\n    const [start, end] = userConfig && userConfig.interpolation\n        ? userConfig.interpolation\n        : defaultConfig.interpolation;\n    return new RegExp(`${start}(.*?)${end}`, 'g');\n}\nfunction getFunctionArgs(argsString) {\n    const splitted = argsString ? argsString.split(',') : [];\n    const args = [];\n    for (let i = 0; i < splitted.length; i++) {\n        let value = splitted[i].trim();\n        while (value[value.length - 1] === '\\\\') {\n            i++;\n            value = value.replace('\\\\', ',') + splitted[i];\n        }\n        args.push(value);\n    }\n    return args;\n}\nclass FunctionalTranspiler extends DefaultTranspiler {\n    constructor(injector) {\n        super();\n        this.injector = injector;\n    }\n    transpile(value, params = {}, translation) {\n        let transpiled = value;\n        if (isString(value)) {\n            transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g, (match, functionName, args) => {\n                try {\n                    const func = this.injector.get(functionName);\n                    return func.transpile(...getFunctionArgs(args));\n                }\n                catch (e) {\n                    let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n                    if (e.message.includes('NullInjectorError')) {\n                        message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n                    }\n                    throw new Error(message);\n                }\n            });\n        }\n        return super.transpile(transpiled, params, translation);\n    }\n}\nFunctionalTranspiler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: FunctionalTranspiler, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });\nFunctionalTranspiler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: FunctionalTranspiler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: FunctionalTranspiler, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });\n\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nclass DefaultHandler {\n    handle(key, config) {\n        if (config.missingHandler.logMissingKey && !config.prodMode) {\n            const msg = `Missing translation for '${key}'`;\n            console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n        }\n        return key;\n    }\n}\nDefaultHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultHandler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultHandler, decorators: [{\n            type: Injectable\n        }] });\n\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nclass DefaultInterceptor {\n    preSaveTranslation(translation) {\n        return translation;\n    }\n    preSaveTranslationKey(_, value) {\n        return value;\n    }\n}\nDefaultInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultInterceptor, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultInterceptor });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultInterceptor, decorators: [{\n            type: Injectable\n        }] });\n\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nclass DefaultFallbackStrategy {\n    constructor(userConfig) {\n        this.userConfig = userConfig;\n    }\n    getNextLangs() {\n        const fallbackLang = this.userConfig.fallbackLang;\n        if (!fallbackLang) {\n            throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n        }\n        return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n    }\n}\nDefaultFallbackStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultFallbackStrategy, deps: [{ token: TRANSLOCO_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultFallbackStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultFallbackStrategy });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: DefaultFallbackStrategy, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }]; } });\n\nfunction mergeConfig(defaultConfig, userConfig) {\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), userConfig), { missingHandler: Object.assign(Object.assign({}, defaultConfig.missingHandler), userConfig.missingHandler), flatten: Object.assign(Object.assign({}, defaultConfig.flatten), userConfig.flatten) });\n}\n\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\nfunction getScopeFromLang(lang) {\n    if (!lang) {\n        return '';\n    }\n    const split = lang.split('/');\n    split.pop();\n    return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\nfunction getLangFromScope(lang) {\n    if (!lang) {\n        return '';\n    }\n    return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\nfunction getPipeValue(str, value, char = '|') {\n    if (isString(str)) {\n        const splitted = str.split(char);\n        const lastItem = splitted.pop();\n        return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n    }\n    return [false, ''];\n}\nfunction shouldListenToLangChanges(service, lang) {\n    const [hasStatic] = getPipeValue(lang, 'static');\n    if (!hasStatic) {\n        // If we didn't get 'lang|static' check if it's set in the global level\n        return !!service.config.reRenderOnLangChange;\n    }\n    // We have 'lang|static' so don't listen to lang changes\n    return false;\n}\nfunction listenOrNotOperator(listenToLangChange) {\n    return listenToLangChange ? (source) => source : take(1);\n}\nfunction prependScope(inlineLoader, scope) {\n    return Object.keys(inlineLoader).reduce((acc, lang) => {\n        acc[`${scope}/${lang}`] = inlineLoader[lang];\n        return acc;\n    }, {});\n}\nfunction resolveInlineLoader(providerScope, scope) {\n    return hasInlineLoader(providerScope)\n        ? prependScope(providerScope.loader, scope)\n        : undefined;\n}\nfunction getEventPayload(lang) {\n    return {\n        scope: getScopeFromLang(lang) || null,\n        langName: getLangFromScope(lang),\n    };\n}\n\nfunction resolveLoader(options) {\n    const { path, inlineLoader, mainLoader, data } = options;\n    if (inlineLoader) {\n        const pathLoader = inlineLoader[path];\n        if (isFunction(pathLoader) === false) {\n            throw `You're using an inline loader but didn't provide a loader for ${path}`;\n        }\n        return inlineLoader[path]().then((res) => res.default ? res.default : res);\n    }\n    return mainLoader.getTranslation(path, data);\n}\n\nfunction getFallbacksLoaders({ mainLoader, path, data, fallbackPath, inlineLoader, }) {\n    const paths = fallbackPath ? [path, fallbackPath] : [path];\n    return paths.map((path) => {\n        const loader = resolveLoader({ path, mainLoader, inlineLoader, data });\n        return from(loader).pipe(map((translation) => ({\n            translation,\n            lang: path,\n        })));\n    });\n}\n\nlet service;\nfunction translate(key, params = {}, lang) {\n    return service.translate(key, params, lang);\n}\nclass TranslocoService {\n    constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n        this.loader = loader;\n        this.parser = parser;\n        this.missingHandler = missingHandler;\n        this.interceptor = interceptor;\n        this.userConfig = userConfig;\n        this.fallbackStrategy = fallbackStrategy;\n        this.subscription = null;\n        this.translations = new Map();\n        this.cache = new Map();\n        this.defaultLang = '';\n        this.availableLangs = [];\n        this.isResolvedMissingOnce = false;\n        this.failedLangs = new Set();\n        this.events = new Subject();\n        this.events$ = this.events.asObservable();\n        if (!this.loader) {\n            this.loader = new DefaultLoader(this.translations);\n        }\n        service = this;\n        this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);\n        this.setAvailableLangs(this.mergedConfig.availableLangs || []);\n        this.setFallbackLangForMissingTranslation(this.mergedConfig);\n        this.setDefaultLang(this.mergedConfig.defaultLang);\n        this.lang = new BehaviorSubject(this.getDefaultLang());\n        // Don't use distinctUntilChanged as we need the ability to update\n        // the value when using setTranslation or setTranslationKeys\n        this.langChanges$ = this.lang.asObservable();\n        /**\n         * When we have a failure, we want to define the next language that succeeded as the active\n         */\n        this.subscription = this.events$.subscribe((e) => {\n            if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n                this.setActiveLang(e.payload.langName);\n            }\n        });\n    }\n    get config() {\n        return this.mergedConfig;\n    }\n    getDefaultLang() {\n        return this.defaultLang;\n    }\n    setDefaultLang(lang) {\n        this.defaultLang = lang;\n    }\n    getActiveLang() {\n        return this.lang.getValue();\n    }\n    setActiveLang(lang) {\n        var _a, _b;\n        this.lang.next(lang);\n        (_b = (_a = this.parser).onLangChanged) === null || _b === void 0 ? void 0 : _b.call(_a, lang);\n        return this;\n    }\n    setAvailableLangs(langs) {\n        this.availableLangs = langs;\n    }\n    /**\n     * Gets the available languages.\n     *\n     * @returns\n     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n     * depending on how the available languages are set in your module.\n     */\n    getAvailableLangs() {\n        return this.availableLangs;\n    }\n    load(path, options = {}) {\n        const cached = this.cache.get(path);\n        if (cached) {\n            return cached;\n        }\n        let loadTranslation;\n        const isScope = this._isLangScoped(path);\n        let scope;\n        if (isScope) {\n            scope = getScopeFromLang(path);\n        }\n        const loadersOptions = {\n            path,\n            mainLoader: this.loader,\n            inlineLoader: options.inlineLoader,\n            data: isScope ? { scope: scope } : undefined,\n        };\n        if (this.useFallbackTranslation(path)) {\n            // if the path is scope the fallback should be `scope/fallbackLang`;\n            const fallback = isScope\n                ? `${scope}/${this.firstFallbackLang}`\n                : this.firstFallbackLang;\n            const loaders = getFallbacksLoaders(Object.assign(Object.assign({}, loadersOptions), { fallbackPath: fallback }));\n            loadTranslation = forkJoin(loaders);\n        }\n        else {\n            const loader = resolveLoader(loadersOptions);\n            loadTranslation = from(loader);\n        }\n        const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap((translation) => {\n            if (Array.isArray(translation)) {\n                translation.forEach((t) => {\n                    this.handleSuccess(t.lang, t.translation);\n                    // Save the fallback in cache so we'll not create a redundant request\n                    if (t.lang !== path) {\n                        this.cache.set(t.lang, of({}));\n                    }\n                });\n                return;\n            }\n            this.handleSuccess(path, translation);\n        }), catchError((error) => {\n            if (!this.mergedConfig.prodMode) {\n                console.error(`Error while trying to load \"${path}\"`, error);\n            }\n            return this.handleFailure(path, options);\n        }), shareReplay(1));\n        this.cache.set(path, load$);\n        return load$;\n    }\n    /**\n     * Gets the instant translated value of a key\n     *\n     * @example\n     *\n     * translate<string>('hello')\n     * translate('hello', { value: 'value' })\n     * translate<string[]>(['hello', 'key'])\n     * translate('hello', { }, 'en')\n     * translate('scope.someKey', { }, 'en')\n     */\n    translate(key, params = {}, lang = this.getActiveLang()) {\n        if (!key)\n            return key;\n        const { scope, resolveLang } = this.resolveLangAndScope(lang);\n        if (Array.isArray(key)) {\n            return key.map((k) => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n        }\n        key = scope ? `${scope}.${key}` : key;\n        const translation = this.getTranslation(resolveLang);\n        const value = translation[key];\n        if (!value) {\n            return this._handleMissingKey(key, value, params);\n        }\n        return this.parser.transpile(value, params, translation);\n    }\n    /**\n     * Gets the translated value of a key as observable\n     *\n     * @example\n     *\n     * selectTranslate<string>('hello').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n     *\n     */\n    selectTranslate(key, params, lang, _isObject = false) {\n        let inlineLoader;\n        const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject\n            ? this.translateObject(key, params, lang)\n            : this.translate(key, params, lang)));\n        if (isNil(lang)) {\n            return this.langChanges$.pipe(switchMap((lang) => load(lang)));\n        }\n        if (isScopeObject(lang)) {\n            // it's a scope object.\n            const providerScope = lang;\n            lang = providerScope.scope;\n            inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n        }\n        lang = lang;\n        if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n            return load(lang);\n        }\n        // it's a scope\n        const scope = lang;\n        return this.langChanges$.pipe(switchMap((lang) => load(`${scope}/${lang}`, { inlineLoader })));\n    }\n    /**\n     * Whether the scope with lang\n     *\n     * @example\n     *\n     * todos/en => true\n     * todos => false\n     */\n    isScopeWithLang(lang) {\n        return this.isLang(getLangFromScope(lang));\n    }\n    translateObject(key, params = {}, lang = this.getActiveLang()) {\n        if (isString(key) || Array.isArray(key)) {\n            if (Array.isArray(key)) {\n                return key.map((k) => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n            }\n            const { resolveLang, scope } = this.resolveLangAndScope(lang);\n            const translation = this.getTranslation(resolveLang);\n            key = scope ? `${scope}.${key}` : key;\n            const value = unflatten(this.getObjectByKey(translation, key));\n            /* If an empty object was returned we want to try and translate the key as a string and not an object */\n            return isEmpty(value)\n                ? this.translate(key, params, lang)\n                : this.parser.transpile(value, params, translation);\n        }\n        const translations = [];\n        for (const [_key, _params] of this.getEntries(key)) {\n            translations.push(this.translateObject(_key, _params, lang));\n        }\n        return translations;\n    }\n    selectTranslateObject(key, params, lang) {\n        if (isString(key) || Array.isArray(key)) {\n            return this.selectTranslate(key, params, lang, true);\n        }\n        const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map((value) => {\n            const translations = [value];\n            for (const [_key, _params] of rest) {\n                translations.push(this.translateObject(_key, _params, lang));\n            }\n            return translations;\n        }));\n    }\n    getTranslation(langOrScope) {\n        if (langOrScope) {\n            if (this.isLang(langOrScope)) {\n                return this.translations.get(langOrScope) || {};\n            }\n            else {\n                // This is a scope, build the scope value from the translation object\n                const { scope, resolveLang } = this.resolveLangAndScope(langOrScope);\n                const translation = this.translations.get(resolveLang) || {};\n                return this.getObjectByKey(translation, scope);\n            }\n        }\n        return this.translations;\n    }\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * selectTranslation().subscribe() - will return the current lang translation\n     * selectTranslation('es').subscribe()\n     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n     * selectTranslation('admin-page/es').subscribe()\n     */\n    selectTranslation(lang) {\n        let language$ = this.langChanges$;\n        if (lang) {\n            const scopeLangSpecified = getLangFromScope(lang) !== lang;\n            if (this.isLang(lang) || scopeLangSpecified) {\n                language$ = of(lang);\n            }\n            else {\n                language$ = this.langChanges$.pipe(map((currentLang) => `${lang}/${currentLang}`));\n            }\n        }\n        return language$.pipe(switchMap((language) => this.load(language).pipe(map(() => this.getTranslation(language)))));\n    }\n    /**\n     * Sets or merge a given translation object to current lang\n     *\n     * @example\n     *\n     * setTranslation({ ... })\n     * setTranslation({ ... }, 'en')\n     * setTranslation({ ... }, 'es', { merge: false } )\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\n     */\n    setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n        const defaults = { merge: true, emitChange: true };\n        const mergedOptions = Object.assign(Object.assign({}, defaults), options);\n        const scope = getScopeFromLang(lang);\n        /**\n         * If this isn't a scope we use the whole translation as is\n         * otherwise we need to flat the scope and use it\n         */\n        let flattenScopeOrTranslation = translation;\n        // Merged the scoped language into the active language\n        if (scope) {\n            const key = this.getMappedScope(scope);\n            flattenScopeOrTranslation = flatten({ [key]: translation });\n        }\n        const currentLang = scope ? getLangFromScope(lang) : lang;\n        const mergedTranslation = Object.assign(Object.assign({}, (mergedOptions.merge && this.getTranslation(currentLang))), flattenScopeOrTranslation);\n        const flattenTranslation = this.mergedConfig.flatten.aot\n            ? mergedTranslation\n            : flatten(mergedTranslation);\n        const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n        this.translations.set(currentLang, withHook);\n        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n    }\n    /**\n     * Sets translation key with given value\n     *\n     * @example\n     *\n     * setTranslationKey('key', 'value')\n     * setTranslationKey('key.nested', 'value')\n     * setTranslationKey('key.nested', 'value', 'en')\n     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n     */\n    setTranslationKey(key, value, \n    // Todo: Add the lang to the options in v3\n    lang = this.getActiveLang(), options = {}) {\n        const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n        const newValue = {\n            [key]: withHook,\n        };\n        this.setTranslation(newValue, lang, Object.assign(Object.assign({}, options), { merge: true }));\n    }\n    /**\n     * Sets the fallback lang for the currently active language\n     * @param fallbackLang\n     */\n    setFallbackLangForMissingTranslation({ fallbackLang, }) {\n        const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n        if (fallbackLang && this.useFallbackTranslation(lang)) {\n            this.firstFallbackLang = lang;\n        }\n    }\n    /**\n     * @internal\n     */\n    _handleMissingKey(key, value, params) {\n        if (this.config.missingHandler.allowEmpty && value === '') {\n            return '';\n        }\n        if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n            // We need to set it to true to prevent a loop\n            this.isResolvedMissingOnce = true;\n            const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n            this.isResolvedMissingOnce = false;\n            return fallbackValue;\n        }\n        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n    }\n    /**\n     * @internal\n     */\n    _isLangScoped(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) === -1;\n    }\n    /**\n     * Checks if a given string is one of the specified available languages.\n     * @returns\n     * True if the given string is an available language.\n     * False if the given string is not an available language.\n     */\n    isLang(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) !== -1;\n    }\n    /**\n     * @internal\n     *\n     * We always want to make sure the global lang is loaded\n     * before loading the scope since you can access both via the pipe/directive.\n     */\n    _loadDependencies(path, inlineLoader) {\n        const mainLang = getLangFromScope(path);\n        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n            return combineLatest(this.load(mainLang), this.load(path, { inlineLoader }));\n        }\n        return this.load(path, { inlineLoader });\n    }\n    /**\n     * @internal\n     */\n    _completeScopeWithLang(langOrScope) {\n        if (this._isLangScoped(langOrScope) &&\n            !this.isLang(getLangFromScope(langOrScope))) {\n            return `${langOrScope}/${this.getActiveLang()}`;\n        }\n        return langOrScope;\n    }\n    /**\n     * @internal\n     */\n    _setScopeAlias(scope, alias) {\n        if (!this.mergedConfig.scopeMapping) {\n            this.mergedConfig.scopeMapping = {};\n        }\n        this.mergedConfig.scopeMapping[scope] = alias;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n        // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n        // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n        // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n        // and destroyed per each HTTP request, but any service is not getting GC'd.\n        this.cache.clear();\n    }\n    isLoadedTranslation(lang) {\n        return size(this.getTranslation(lang));\n    }\n    getAvailableLangsIds() {\n        const first = this.getAvailableLangs()[0];\n        if (isString(first)) {\n            return this.getAvailableLangs();\n        }\n        return this.getAvailableLangs().map((l) => l.id);\n    }\n    getMissingHandlerData() {\n        return Object.assign(Object.assign({}, this.config), { activeLang: this.getActiveLang(), availableLangs: this.availableLangs, defaultLang: this.defaultLang });\n    }\n    /**\n     * Use a fallback translation set for missing keys of the primary language\n     * This is unrelated to the fallback language (which changes the active language)\n     */\n    useFallbackTranslation(lang) {\n        return (this.config.missingHandler.useFallbackTranslation &&\n            lang !== this.firstFallbackLang);\n    }\n    handleSuccess(lang, translation) {\n        this.setTranslation(translation, lang, { emitChange: false });\n        this.events.next({\n            wasFailure: !!this.failedLangs.size,\n            type: 'translationLoadSuccess',\n            payload: getEventPayload(lang),\n        });\n        this.failedLangs.forEach((l) => this.cache.delete(l));\n        this.failedLangs.clear();\n    }\n    handleFailure(lang, loadOptions) {\n        // When starting to load a first choice language, initialize\n        // the failed counter and resolve the fallback langs.\n        if (isNil(loadOptions.failedCounter)) {\n            loadOptions.failedCounter = 0;\n            if (!loadOptions.fallbackLangs) {\n                loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n            }\n        }\n        const splitted = lang.split('/');\n        const fallbacks = loadOptions.fallbackLangs;\n        const nextLang = fallbacks[loadOptions.failedCounter];\n        this.failedLangs.add(lang);\n        // This handles the case where a loaded fallback language is requested again\n        if (this.cache.has(nextLang)) {\n            this.handleSuccess(nextLang, this.getTranslation(nextLang));\n            return EMPTY;\n        }\n        const isFallbackLang = nextLang === splitted[splitted.length - 1];\n        if (!nextLang || isFallbackLang) {\n            let msg = `Unable to load translation and all the fallback languages`;\n            if (splitted.length > 1) {\n                msg += `, did you misspelled the scope name?`;\n            }\n            throw new Error(msg);\n        }\n        let resolveLang = nextLang;\n        // if it's scoped lang\n        if (splitted.length > 1) {\n            // We need to resolve it to:\n            // todos/langNotExists => todos/nextLang\n            splitted[splitted.length - 1] = nextLang;\n            resolveLang = splitted.join('/');\n        }\n        loadOptions.failedCounter++;\n        this.events.next({\n            type: 'translationLoadFailure',\n            payload: getEventPayload(lang),\n        });\n        return this.load(resolveLang, loadOptions);\n    }\n    getMappedScope(scope) {\n        const { scopeMapping = {} } = this.config;\n        return scopeMapping[scope] || toCamelCase(scope);\n    }\n    /**\n     * If lang is scope we need to check the following cases:\n     * todos/es => in this case we should take `es` as lang\n     * todos => in this case we should set the active lang as lang\n     */\n    resolveLangAndScope(lang) {\n        let resolveLang = lang;\n        let scope;\n        if (this._isLangScoped(lang)) {\n            // en for example\n            const langFromScope = getLangFromScope(lang);\n            // en is lang\n            const hasLang = this.isLang(langFromScope);\n            // take en\n            resolveLang = hasLang ? langFromScope : this.getActiveLang();\n            // find the scope\n            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n        }\n        return { scope, resolveLang };\n    }\n    getObjectByKey(translation, key) {\n        const result = {};\n        const prefix = `${key}.`;\n        for (const currentKey in translation) {\n            if (currentKey.startsWith(prefix)) {\n                result[currentKey.replace(prefix, '')] = translation[currentKey];\n            }\n        }\n        return result;\n    }\n    getEntries(key) {\n        return key instanceof Map ? key.entries() : Object.entries(key);\n    }\n}\nTranslocoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoService, deps: [{ token: TRANSLOCO_LOADER, optional: true }, { token: TRANSLOCO_TRANSPILER }, { token: TRANSLOCO_MISSING_HANDLER }, { token: TRANSLOCO_INTERCEPTOR }, { token: TRANSLOCO_CONFIG }, { token: TRANSLOCO_FALLBACK_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });\nTranslocoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoService, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LOADER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_TRANSPILER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_MISSING_HANDLER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_INTERCEPTOR]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_FALLBACK_STRATEGY]\n                }] }]; } });\n\nclass TranslocoLoaderComponent {\n}\nTranslocoLoaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoLoaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nTranslocoLoaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"12.2.5\", type: TranslocoLoaderComponent, selector: \"ng-component\", inputs: { html: \"html\" }, ngImport: i0, template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `, isInline: true });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoLoaderComponent, decorators: [{\n            type: Component,\n            args: [{\n                    template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `,\n                }]\n        }], propDecorators: { html: [{\n                type: Input\n            }] } });\n\nclass TemplateHandler {\n    constructor(view, vcr) {\n        this.view = view;\n        this.vcr = vcr;\n        this.injector = this.vcr.injector;\n    }\n    attachView() {\n        if (this.view instanceof TemplateRef) {\n            this.vcr.createEmbeddedView(this.view);\n        }\n        else if (isString(this.view)) {\n            const componentRef = this.createComponent(TranslocoLoaderComponent);\n            componentRef.instance.html = this.view;\n            componentRef.hostView.detectChanges();\n        }\n        else {\n            this.createComponent(this.view);\n        }\n    }\n    detachView() {\n        this.vcr.clear();\n    }\n    createComponent(cmp) {\n        const cfr = this.injector.get(ComponentFactoryResolver);\n        const factory = cfr.resolveComponentFactory(cmp);\n        return this.vcr.createComponent(factory);\n    }\n}\n\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\n\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\n\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\nclass LangResolver {\n    constructor() {\n        this.initialized = false;\n    }\n    // inline => provider => active\n    resolve({ inline, provider, active }) {\n        let lang = active;\n        /**\n         * When the user changes the lang we need to update\n         * the view. Otherwise, the lang will remain the inline/provided lang\n         */\n        if (this.initialized) {\n            lang = active;\n            return lang;\n        }\n        if (provider) {\n            const [, extracted] = getPipeValue(provider, 'static');\n            lang = extracted;\n        }\n        if (inline) {\n            const [, extracted] = getPipeValue(inline, 'static');\n            lang = extracted;\n        }\n        this.initialized = true;\n        return lang;\n    }\n    /**\n     *\n     * Resolve the lang\n     *\n     * @example\n     *\n     * resolveLangBasedOnScope('todos/en') => en\n     * resolveLangBasedOnScope('en') => en\n     *\n     */\n    resolveLangBasedOnScope(lang) {\n        const scope = getScopeFromLang(lang);\n        return scope ? getLangFromScope(lang) : lang;\n    }\n    /**\n     *\n     * Resolve the lang path for loading\n     *\n     * @example\n     *\n     * resolveLangPath('todos', 'en') => todos/en\n     * resolveLangPath('en') => en\n     *\n     */\n    resolveLangPath(lang, scope) {\n        return scope ? `${scope}/${lang}` : lang;\n    }\n}\n\nclass ScopeResolver {\n    constructor(translocoService) {\n        this.translocoService = translocoService;\n    }\n    // inline => provider\n    resolve({ inline, provider } = {\n        inline: undefined,\n        provider: undefined,\n    }) {\n        if (inline) {\n            return inline;\n        }\n        if (provider) {\n            if (isScopeObject(provider)) {\n                const { scope, alias = toCamelCase(scope) } = provider;\n                this.translocoService._setScopeAlias(scope, alias);\n                return scope;\n            }\n            return provider;\n        }\n        return undefined;\n    }\n}\n\nclass TranslocoDirective {\n    constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host) {\n        this.translocoService = translocoService;\n        this.tpl = tpl;\n        this.providerScope = providerScope;\n        this.providerLang = providerLang;\n        this.providedLoadingTpl = providedLoadingTpl;\n        this.vcr = vcr;\n        this.cdr = cdr;\n        this.host = host;\n        this.subscription = null;\n        this.translationMemo = {};\n        this.params = {};\n        // Whether we already rendered the view once\n        this.initialized = false;\n        this.langResolver = new LangResolver();\n        this.scopeResolver = new ScopeResolver(this.translocoService);\n    }\n    static ngTemplateContextGuard(dir, ctx) {\n        return true;\n    }\n    ngOnInit() {\n        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n        this.subscription = this.translocoService.langChanges$\n            .pipe(switchMap((activeLang) => {\n            const lang = this.langResolver.resolve({\n                inline: this.inlineLang,\n                provider: this.providerLang,\n                active: activeLang,\n            });\n            return Array.isArray(this.providerScope)\n                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))\n                : this.resolveScope(lang, this.providerScope);\n        }), listenOrNotOperator(listenToLangChange))\n            .subscribe(() => {\n            this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n            this.tpl === null\n                ? this.simpleStrategy()\n                : this.structuralStrategy(this.currentLang, this.inlineRead);\n            this.cdr.markForCheck();\n            this.initialized = true;\n        });\n        const loadingTpl = this.getLoadingTpl();\n        if (!this.initialized && loadingTpl) {\n            this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n            this.loaderTplHandler.attachView();\n        }\n    }\n    ngOnChanges(changes) {\n        // We need to support dynamic keys/params, so if this is not the first change CD cycle\n        // we need to run the function again in order to update the value\n        const notInit = Object.keys(changes).some((v) => !changes[v].firstChange);\n        notInit && this.simpleStrategy();\n    }\n    simpleStrategy() {\n        this.detachLoader();\n        this.host.nativeElement.innerText = this.translocoService.translate(this.key, this.params, this.currentLang);\n    }\n    structuralStrategy(lang, read) {\n        this.translationMemo = {};\n        if (this.view) {\n            // when the lang changes we need to change the reference so Angular will update the view\n            this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n            this.view.context['currentLang'] = this.currentLang;\n        }\n        else {\n            this.detachLoader();\n            this.view = this.vcr.createEmbeddedView(this.tpl, {\n                $implicit: this.getTranslateFn(lang, read),\n                currentLang: this.currentLang,\n            });\n        }\n    }\n    getTranslateFn(lang, read) {\n        return (key, params) => {\n            const withRead = read ? `${read}.${key}` : key;\n            const withParams = params\n                ? `${withRead}${JSON.stringify(params)}`\n                : withRead;\n            if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n                return this.translationMemo[withParams].value;\n            }\n            this.translationMemo[withParams] = {\n                params,\n                value: this.translocoService.translate(withRead, params, lang),\n            };\n            return this.translationMemo[withParams].value;\n        };\n    }\n    getLoadingTpl() {\n        return this.inlineTpl || this.providedLoadingTpl;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n    }\n    detachLoader() {\n        var _a;\n        (_a = this.loaderTplHandler) === null || _a === void 0 ? void 0 : _a.detachView();\n    }\n    resolveScope(lang, providerScope) {\n        const resolvedScope = this.scopeResolver.resolve({\n            inline: this.inlineScope,\n            provider: providerScope,\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n}\nTranslocoDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoDirective, deps: [{ token: TranslocoService }, { token: i0.TemplateRef, optional: true }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: TRANSLOCO_LOADING_TEMPLATE, optional: true }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\nTranslocoDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.5\", type: TranslocoDirective, selector: \"[transloco]\", inputs: { key: [\"transloco\", \"key\"], params: [\"translocoParams\", \"params\"], inlineScope: [\"translocoScope\", \"inlineScope\"], inlineRead: [\"translocoRead\", \"inlineRead\"], inlineLang: [\"translocoLang\", \"inlineLang\"], inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"] }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[transloco]',\n                }]\n        }], ctorParameters: function () { return [{ type: TranslocoService }, { type: i0.TemplateRef, decorators: [{\n                    type: Optional\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_SCOPE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LANG]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LOADING_TEMPLATE]\n                }] }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, propDecorators: { key: [{\n                type: Input,\n                args: ['transloco']\n            }], params: [{\n                type: Input,\n                args: ['translocoParams']\n            }], inlineScope: [{\n                type: Input,\n                args: ['translocoScope']\n            }], inlineRead: [{\n                type: Input,\n                args: ['translocoRead']\n            }], inlineLang: [{\n                type: Input,\n                args: ['translocoLang']\n            }], inlineTpl: [{\n                type: Input,\n                args: ['translocoLoadingTpl']\n            }] } });\n\nclass TranslocoPipe {\n    constructor(translocoService, providerScope, providerLang, cdr) {\n        this.translocoService = translocoService;\n        this.providerScope = providerScope;\n        this.providerLang = providerLang;\n        this.cdr = cdr;\n        this.subscription = null;\n        this.lastValue = '';\n        this.langResolver = new LangResolver();\n        this.scopeResolver = new ScopeResolver(this.translocoService);\n    }\n    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n    transform(key, params, inlineLang) {\n        var _a;\n        if (!key) {\n            return key;\n        }\n        const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n        if (keyName === this.lastKey) {\n            return this.lastValue;\n        }\n        this.lastKey = keyName;\n        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);\n        this.subscription = this.translocoService.langChanges$\n            .pipe(switchMap((activeLang) => {\n            const lang = this.langResolver.resolve({\n                inline: inlineLang,\n                provider: this.providerLang,\n                active: activeLang,\n            });\n            return Array.isArray(this.providerScope)\n                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))\n                : this.resolveScope(lang, this.providerScope);\n        }), listenOrNotOperator(listenToLangChange))\n            .subscribe(() => this.updateValue(key, params));\n        return this.lastValue;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n    }\n    updateValue(key, params) {\n        const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.lastValue = this.translocoService.translate(key, params, lang);\n        this.cdr.markForCheck();\n    }\n    resolveScope(lang, providerScope) {\n        const resolvedScope = this.scopeResolver.resolve({\n            inline: undefined,\n            provider: providerScope,\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n}\nTranslocoPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoPipe, deps: [{ token: TranslocoService }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Pipe });\nTranslocoPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoPipe, name: \"transloco\", pure: false });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoPipe, decorators: [{\n            type: Pipe,\n            args: [{\n                    name: 'transloco',\n                    pure: false,\n                }]\n        }], ctorParameters: function () { return [{ type: TranslocoService }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_SCOPE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LANG]\n                }] }, { type: i0.ChangeDetectorRef }]; } });\n\nconst defaultProviders = [\n    {\n        provide: TRANSLOCO_TRANSPILER,\n        useClass: DefaultTranspiler,\n        deps: [TRANSLOCO_CONFIG],\n    },\n    {\n        provide: TRANSLOCO_MISSING_HANDLER,\n        useClass: DefaultHandler,\n    },\n    {\n        provide: TRANSLOCO_INTERCEPTOR,\n        useClass: DefaultInterceptor,\n    },\n    {\n        provide: TRANSLOCO_FALLBACK_STRATEGY,\n        useClass: DefaultFallbackStrategy,\n        deps: [TRANSLOCO_CONFIG],\n    },\n];\nclass TranslocoModule {\n}\nTranslocoModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nTranslocoModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoModule, declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent], exports: [TranslocoDirective, TranslocoPipe] });\nTranslocoModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoModule, providers: [defaultProviders] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n                    providers: [defaultProviders],\n                    exports: [TranslocoDirective, TranslocoPipe],\n                    entryComponents: [TranslocoLoaderComponent],\n                }]\n        }] });\n\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nclass TestingLoader {\n    constructor(langs) {\n        this.langs = langs;\n    }\n    getTranslation(lang) {\n        return of(this.langs[lang]);\n    }\n}\nTestingLoader.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TestingLoader, deps: [{ token: TRANSLOCO_TEST_LANGS }], target: i0.ɵɵFactoryTarget.Injectable });\nTestingLoader.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TestingLoader });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TestingLoader, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_TEST_LANGS]\n                }] }]; } });\nfunction initTranslocoService(service, langs = {}, options) {\n    const preloadAllLangs = () => options.preloadLangs\n        ? Promise.all(Object.keys(langs).map((lang) => service.load(lang).toPromise()))\n        : Promise.resolve();\n    return preloadAllLangs;\n}\nclass TranslocoTestingModule {\n    static forRoot(options) {\n        return {\n            ngModule: TranslocoTestingModule,\n            providers: [\n                {\n                    provide: TRANSLOCO_TEST_LANGS,\n                    useValue: options.langs,\n                },\n                {\n                    provide: TRANSLOCO_TEST_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: APP_INITIALIZER,\n                    useFactory: initTranslocoService,\n                    deps: [\n                        TranslocoService,\n                        TRANSLOCO_TEST_LANGS,\n                        TRANSLOCO_TEST_OPTIONS,\n                    ],\n                    multi: true,\n                },\n                {\n                    provide: TRANSLOCO_LOADER,\n                    useClass: TestingLoader,\n                },\n                defaultProviders,\n                {\n                    provide: TRANSLOCO_CONFIG,\n                    useValue: translocoConfig(Object.assign({ prodMode: true, missingHandler: { logMissingKey: false } }, options.translocoConfig)),\n                },\n            ],\n        };\n    }\n}\nTranslocoTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nTranslocoTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoTestingModule, exports: [TranslocoModule] });\nTranslocoTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoTestingModule, imports: [TranslocoModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.5\", ngImport: i0, type: TranslocoTestingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [TranslocoModule],\n                }]\n        }] });\n\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\nfunction getBrowserLang() {\n    let browserLang = getBrowserCultureLang();\n    if (!browserLang || !isBrowser()) {\n        return undefined;\n    }\n    if (browserLang.indexOf('-') !== -1) {\n        browserLang = browserLang.split('-')[0];\n    }\n    if (browserLang.indexOf('_') !== -1) {\n        browserLang = browserLang.split('_')[0];\n    }\n    return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\nfunction getBrowserCultureLang() {\n    if (!isBrowser()) {\n        return '';\n    }\n    const navigator = window.navigator;\n    let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n    browserCultureLang =\n        browserCultureLang ||\n            navigator.language ||\n            navigator.browserLanguage ||\n            navigator.userLanguage;\n    return browserCultureLang;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TemplateHandler, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, defaultProviders, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeObject, isString, setValue, size, toCamelCase, toNumber, translate, translocoConfig, unflatten };\n"]},"metadata":{},"sourceType":"module"}